package utils

import (
	"context"
	"strconv"
	"strings"

	"github.com/accurics/terrascan/pkg/iac-providers/output"
)

// GetVulnerabilitiesUsingTrivyCLI scans image using trivy as cli
func GetVulnerabilitiesUsingTrivyCLI(configs output.AllResourceConfigs) output.AllResourceConfigs {
	for i, v := range configs {
		for j, config := range v {
			for k, container := range config.ContainerImages {

				results, err := ScanDockerImageWithTrivyCLI(container.Image)
				if err != nil {
					continue
				}
				for _, result := range results {
					for _, vul := range result.Vulnerabilities {
						vulnerabilityConfig := output.VulnerabilityConfig{
							result.Target,
							result.Type,
							vul,
						}
						configs[i][j].ContainerImages[k].Vulnerabilities = append(configs[i][j].ContainerImages[k].Vulnerabilities, vulnerabilityConfig)

					}
				}
			}
			for l, container := range config.InitContainerImages {

				results, err := ScanDockerImageWithTrivyCLI(container.Image)
				if err != nil {
					continue
				}
				for _, result := range results {
					for _, vul := range result.Vulnerabilities {
						vulnerabilityConfig := output.VulnerabilityConfig{
							result.Target,
							result.Type,
							vul,
						}
						configs[i][j].InitContainerImages[l].Vulnerabilities = append(configs[i][j].InitContainerImages[l].Vulnerabilities, vulnerabilityConfig)

					}
				}
			}
		}

	}

	return configs
}

// GetVulnerabilitiesUsingTrivyServer scans image using trivy as server
func GetVulnerabilitiesUsingTrivyServer(configs output.AllResourceConfigs) output.AllResourceConfigs {
	results := output.Results{}
	var err error
	for i, v := range configs {
		for j, config := range v {
			for k, container := range config.ContainerImages {
				results, err = ScanDockerImageWithTrivyServer(context.Background(), container.Image)
				if err != nil {
					continue
				}
				for _, result := range results {
					for _, vul := range result.Vulnerabilities {
						vulnerabilityConfig := output.VulnerabilityConfig{
							result.Target,
							result.Type,
							vul,
						}
						configs[i][j].ContainerImages[k].Vulnerabilities = append(configs[i][j].ContainerImages[k].Vulnerabilities, vulnerabilityConfig)

					}
				}
			}
			for l, container := range config.InitContainerImages {
				results, err := ScanDockerImageWithTrivyServer(context.Background(), container.Image)
				if err != nil {
					continue
				}
				for _, result := range results {
					for _, vul := range result.Vulnerabilities {
						vulnerabilityConfig := output.VulnerabilityConfig{
							result.Target,
							result.Type,
							vul,
						}
						configs[i][j].InitContainerImages[l].Vulnerabilities = append(configs[i][j].InitContainerImages[l].Vulnerabilities, vulnerabilityConfig)

					}
				}
			}
		}
	}

	return configs
}

// GetVulnerabilitiesUsingECRAPI scans image using ECR scan
func GetVulnerabilitiesUsingECRAPI(configs output.AllResourceConfigs) output.AllResourceConfigs {
	for i, v := range configs {
		for j, config := range v {
			for k, container := range config.ContainerImages {
				results, err := ScanImageWithAWSECRAPI(context.Background(), container.Image)
				if err != nil {
					continue
				}
				//TODO: need write better parser for this
				if results == nil || results.ImageScanFindings == nil || results.ImageScanFindings.Findings == nil {
					return configs
				}
				for _, result := range results.ImageScanFindings.Findings {

					vulnerabilityConfig := output.VulnerabilityConfig{}
					if result.Severity != nil {
						vulnerabilityConfig.Severity = *result.Severity
					}
					if result.Description != nil {
						vulnerabilityConfig.Description = *result.Description
					}
					if result.Name != nil {
						vulnerabilityConfig.VulnerabilityID = *result.Name
					}
					if result.Uri != nil {
						vulnerabilityConfig.PrimaryURL = *result.Uri
					}
					cvss := output.CVSS{}
					if result.Attributes != nil {
						for _, attr := range result.Attributes {
							if attr.Key == nil || attr.Value == nil {
								continue
							}
							if strings.EqualFold(*attr.Key, "package_name") {
								vulnerabilityConfig.PkgName = *attr.Value
							}
							if strings.EqualFold(*attr.Key, "package_version") {
								vulnerabilityConfig.InstalledVersion = *attr.Value
							}
							if strings.Contains(*attr.Key, "CVSS") {
								switch *attr.Key {
								case "CVSS2_VECTOR":
									cvss.V2Vector = *attr.Value
								case "CVSS3_VECTOR":
									cvss.V3Vector = *attr.Value
								case "CVSS2_SCORE":
									if v, err := strconv.ParseFloat(*attr.Value, 64); err == nil {
										cvss.V2Score = v
									}
								case "CVSS3_SCORE":
									if v, err := strconv.ParseFloat(*attr.Value, 64); err == nil {
										cvss.V3Score = v
									}
								}
							}
							m := make(output.VendorCVSS)
							m["nvd"] = cvss
							vulnerabilityConfig.CVSS = m
						}

						configs[i][j].ContainerImages[k].Vulnerabilities = append(configs[i][j].ContainerImages[k].Vulnerabilities, vulnerabilityConfig)

					}
				}

			}
		}
	}
	return configs
}
